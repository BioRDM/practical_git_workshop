---
title: "git and Github"
subtitle: "A practical introduction"
date: 02-18-2026
date-format: DD/MM/YYYY
author: Daniel Thédié
format:
  revealjs:
    self-contained: true
    slide-number: true
    preview-links: auto
    code-block-height: 600px
    footer: ''
---

# Check-in

## House rules

<!-- Lisa will send -->

# What makes you want to use Github?

# What makes you *not* want to use Github?

# Basics of git and github

## What is a git repository?

- A (local) folder
- A `.git` folder that contains all the file history

![](./figures/Empty_git_folder.png)

## How are changes recorded

![](./figures/git_file_states.svg)

- A commit records a snapshot of the project
- It is identified by a unique "hash", e.g. `87c0c975daf0643d59a01222b312662d347e0bfa`
- Shown on github as the first 7 characters for readability: `87c0c97`

## Is git overly complicated?

![](./figures/too-complex.jpg)

Can we not make a google docs for code?

- Real-time updates
- Collaboration
- Complete file history

## What git adds...

![](./figures/Data_management.jpg){.absolute top=5 left=650}

<br>

The process makes the user decide...

- **What** they share (which files)
- **When** they share (working on files locally and pushing them when ready)
- **Why** they share (for other people to use the code, to collaborate on code...)

## How to collaborate with git(hub)

![](./figures/local-copy.jpg){.absolute left=0 width=30%}

![](./figures/git_principle.svg){.absolute right=0 width=70% top=25%}

::: {.absolute left=35% bottom=10%}
Pull - Modify - Stage - Commit - Push
:::

## From theory to practice {.smaller}

::: {.panel-tabset}

### Create repository

:::: {.columns}
::: {.column width=48%}
- Go to `github.com`
- Click on "New"
- Enter a name and description
- Make repository public or private
- Tick "Add a README file"

![](./figures/gh_homepage_new.png)
:::
::: {.column width=2%}
:::
::: {.column width=50%}
- Click on "< > Code"
- Copy the https link to the repository

![](./figures/gh_clone_window.png)
:::
::::

### Clone and edit

:::: {.columns}
::: {.column width=48%}
- In RStudio, create a new project
![](./figures/RStudio_new_project.svg)
- Select:
  - Version control
  - Git
- Enter repository details
- Identify to Github

:::
::: {.column width=4%}
:::
::: {.column width=48%}
- Add some code files to the repository
- They will be shown in the RStudio git tab

![](./figures/RStudio_git_tab.png)
:::
::::

### First commit!

:::: {.columns}
::: {.column width=40%}
- Stage the newly added files

![](./figures/RStudio_staged.png)
:::
::: {.column width=2%}
:::
::: {.column width=58%}
- Commit (with a message)
![](./figures/RStudio_commit.png)

- Push
  - Committed files are now on Github
:::
::::

### Use .gitignore

- Open the `.gitignore` file
- Add `*.Rproj` on a new line
  - The .Rproj file has disappeared from the git tab
- Commit `.gitignore`

:::

## The Readme file

A *practical* overview of the repository, in **markdown** format

- What can be found in here?
- What's the purpose of the code (+ inputs/outputs)
- How to use the code
- Who are the authors (with contact info)

## Readme example

:::: {.columns}
::: {.column width=43%}
![](./figures/Readme_raw.png)
:::
::: {.column width=57%}
![](./figures/Readme_formatted.png)
:::
::::

::: {.footer}
[github.com/BioRDM/Network-Analysis](https://github.com/BioRDM/Network-Analysis)
:::

## Why use branches

![](./figures/git_branches_problem_1.svg)

## Why use branches

![](./figures/git_branches_problem_2.svg)

## Why use branches

![](./figures/git_branches_problem_3.svg)

## Why use branches

![](./figures/git_branches_principle.svg)

## Creating a branch {.nostretch}

- Create a new branch "dev" in your repository
![](./figures/RStudio_git_tab.png){width=60%}

- Make some changes to a file
- Stage, commit, push
- Switch between branches
  - Each branch has a different file version

# Short break

# Good coding practices

## Code modularity {.smaller auto-animate="true"}

<!-- How does it help, how is it achieved -->
<!-- Would be great if I had a minimal example of a short, hard to understand script (with repetitions?) that can be split into functions... -->

<!-- - Makes code more "human-readable" -->

```{.r}
library(readxl)
library(ggplot2)

sessions_file <- "example_sessions.csv"
min_sleep_period <- 2  # hours

file_ext <- tolower(file_ext(sessions_file))
if (file_ext == "csv") {
  sessions <- read.csv(sessions_file)
} else if (file_ext %in% c("xls", "xlsx")) {
  sessions <- read_excel(sessions_file) |>
    as.data.frame()
}

sessions <- sessions[sessions['sleep_period'] >= min_sleep_period * 60 * 60, ]

p <- ggplot(sessions, aes(x = .data$night, y = .data$variable, color = .data$color_group)) +
  geom_point(size = 5) +
  color_scale +
  labs(x = NULL, y = variable, color = NULL) +
  theme_minimal(base_size = 16) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

print(p)
```

## Code modularity {.smaller auto-animate="true"}

```{.r}
sessions_file <- "example_sessions.csv"
min_sleep_period <- 2  # hours

sessions <- load_sessions(sessions_file)

sessions <- set_min_sleep(sessions, min_sleep_period)

print_timeseries_plot(sessions)
```

<br>

- Makes code more human-readable
  - Creates different "levels of reading"
- Facilitates reuse in different scripts
- Facilitates collaborative work

## 1. Create functions

- A "processing unit" with clear inputs and outputs
- Can be described simply with a **verb** + a noun
  - "`load_data`", "`set_ema_period`"
- In general shorter is better

```{.r}
set_min_sleep <- function(sessions, min_sleep) {
  sessions <- sessions[sessions['sleep_period'] >= min_sleep * 60 * 60, ]
  return(sessions)
}
```

## 2. Split code between different files

:::: {.columns}
::: {.column width=20%}
![](./figures/nocturn_R_files.png)
:::
::: {.column width=5%}
:::
::: {.column width=75%}
<br>
```{.r}
source("R/filtering.R")
```

- One file per "topic"
- If a file gets very long, consider splitting it
- Easily see what part of the code a commit has affected

![](./figures/gh_commit_example.png)
:::
::::

<!-- ## Documenting code

- If commenting inside the code, focus on *why* rather than *what*

```{.r}

```

- Docstrings
  - *Optional*
  - Use to document functions that are important and/or might be used by other people -->

## Make your code more modular

- Checkout `dev` branch
- Create functions
- Organise them in different files

Function template:
```{.r}
set_min_sleep <- function(sessions, min_sleep) {
  sessions <- sessions[sessions['sleep_period'] >= min_sleep * 60 * 60, ]
  return(sessions)
}
```

...commit and push your changes to github

# Short break

# GitHub functionalities

## Time to make your first pull request (to yourself)

On github, create a pull request to merge dev into main.

<!-- Here let people do a "no-conflict" merge on their repo -->

## When merges are more complicated

<!-- Do a live demo on my repo where I change the same file in main and dev, and solve the merge conflict -->

## Issues

- Like a centralised to-do list
- Keep track of things to do together
  - When there are multiple users, it's also useful for them to know which bugs have already been reported
- Each issue gets its own discussion feed
- How to close an issue via commit (fixes #1)
- Don't be scared of issues! Code is never perfect
  - Foster a culture of openness

## Github is not the only way

- Github doesn't own git!
- Any other website can provide similar functionalities
- Examples: Gitlab, codeberg, forgejo...
- ...including the Uni's own gitlab instance! (IT resilience)
